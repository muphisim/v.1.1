import time
import math
import re
from subprocess import call
from time import sleep
from re import match
from re import search
from time import sleep
from os import listdir
from os import chdir
from os import remove
from os.path import isfile
from os.path import getsize
from os.path import join
import numpy as np
import os
import pandas as pd
from joblib import Parallel, delayed

'''
This is a python script which converts Hexahedron elements generated by ABAQUS to Tetrahderal elements to be used in MuPhiSim
, and partitions the nodes and elements for parallel processing. The script finally generates an input file (.inp) for MuPhiSim.
'''
########################################
Hex_Mesh = 'AbaqusMesh.inp'   ### Name of the input file generated by ABAQUS, containing Hexahedron elements
Output = 'MuPhiSim_input.inp' ### Name of the input file for MuPhiSim, which is finally generated by this script

### Creating empty arrays for nodes and elements
Node_list = []
Element_list = []
Element_list_hex = []

### Domain dimensions (Here we consider a 3D block)
X_L = 5.0  # 5.0
Y_L = 5.0  # 5.0
Z_L = 2.0  # 2.0

### Number of partitions in each direction
Xd_sec = 2
Yd_sec = 2
Zd_sec = 2

### Total number of partitions
Total_sections = Xd_sec * Yd_sec * Zd_sec

### Partition intervals
Xd_int = X_L / Xd_sec
Yd_int = Y_L / Yd_sec
Zd_int = Z_L / Zd_sec

### Partition grids
Xd = np.around(np.arange(0.0, X_L + Xd_int, Xd_int), 3)
Yd = np.around(np.arange(0.0, Y_L + Yd_int, Yd_int), 3)
Zd = np.around(np.arange(0.0, Z_L + Zd_int, Zd_int), 3)

#### Opening and reading the ABAQUS input file
inpFile = open(Hex_Mesh, 'r')
line = inpFile.readline()

try:
    ### Reading the node and element files if they already exist
    df_node = pd.read_csv("Nodes.csv")
    df_elem = pd.read_csv("ElementsTet.csv")
    df_elem_hex = pd.read_csv("ElementsHex.csv")

except:
    ### Loop to read the file lines
    while line:
        ### if the Node keyword is found (beginning of the node list)
        match = re.search(r"\bNode\b", line)
        if match is not None:
            line = inpFile.readline()
            while line:
                ### if the Element keyword is found (beginning of the element list)
                match = re.search(r"\bElement\b", line)
                if match is not None:
                    line = inpFile.readline()
                    i = 1
                    while line:
                        ### if the Nset keyword is found (end of the element list -> end the search loop)
                        match = re.search(r"\bNset\b", line)
                        if match is not None:
                            break
                        ### Splitting the Hex element node IDs
                        N = list(map(int, line.split(",")))
                        Element_list_hex.append(N)
                        #### Generating the first Tet element
                        E1 = [i, N[1], N[3], N[4], N[7]]
                        Element_list.append(E1)
                        i += 1
                        #### Generating the second Tet element
                        E2 = [i, N[1], N[2], N[3], N[7]]
                        Element_list.append(E2)
                        i += 1
                        #### Generating the third Tet element
                        E3 = [i, N[4], N[1], N[7], N[8]]
                        Element_list.append(E3)
                        i += 1
                        #### Generating the fourth Tet element
                        E4 = [i, N[1], N[5], N[7], N[8]]
                        Element_list.append(E4)
                        i += 1
                        #### Generating the fifth Tet element
                        E5 = [i, N[1], N[5], N[6], N[7]]
                        Element_list.append(E5)
                        i += 1
                        #### Generating the sixth Tet element
                        E6 = [i, N[2], N[1], N[6], N[7]]
                        Element_list.append(E6)
                        i += 1
                        ####

                        line = inpFile.readline()
                    break
                ### Splitting the node coordinates (X,Y,Z)
                Node = list(map(float, line.split(",")))
                Node_list.append(Node)

                line = inpFile.readline()
            break
        line = inpFile.readline()

    ###############################
    ### Storing the node coordinates to a Pandas dataframe
    df_node = pd.DataFrame(Node_list, columns=['ID', 'X', 'Y', 'Z'])
    df_node['X'] = df_node['X'].round(3)
    df_node['Y'] = df_node['Y'].round(3)
    df_node['Z'] = df_node['Z'].round(3)
    df_node["ID"] = df_node["ID"].astype(int)
    ###############################
    ### Storing the Tet element node IDs to a Pandas dataframe
    df_elem = pd.DataFrame(Element_list, columns=['ID', 'Node1', 'Node2', 'Node3', 'Node4'])
    df_elem["ID"] = df_elem["ID"].astype(int)
    ###############################
    ### Storing the Hex element node IDs to a Pandas dataframe
    df_elem_hex = pd.DataFrame(Element_list_hex, columns=['ID', 'Node1', 'Node2', 'Node3', 'Node4',
                                                          'Node5', 'Node6', 'Node7', 'Node8'])
    df_elem_hex["ID"] = df_elem_hex["ID"].astype(int)
    df_elem_hex.drop(["ID"], axis=1, inplace=True)

    ####### Saving the dataframes
    df_node.to_csv("Nodes.csv", index=False)
    df_elem.to_csv("ElementsTet.csv", index=False)
    df_elem_hex.to_csv("ElementsHex.csv", index=False)

section_labels = []
elem_labels = []
inputs = range(Xd_sec)

########
print("Number of nodes is:", df_node.shape[0])
print("Number of elements is:", df_elem.shape[0])

########  Function to divide the partitions for parallel processing
def search_section(i):
    sec_labels = []
    element_labels = []
    for j in range(Yd_sec):
        for k in range(Zd_sec):
            ### Identifying the node ID in each partition
            ID_filter = df_node[((Xd[i] <= df_node["X"]) & (df_node["X"] <= Xd[i + 1])) & (
                    (Yd[j] <= df_node["Y"]) & (df_node["Y"] <= Yd[j + 1]))
                                & ((Zd[k] <= df_node["Z"]) & (df_node["Z"] <= Zd[k + 1]))]["ID"].values
            sec_labels.append(ID_filter)

            ### Categorizing the elements in each partition
            Element_filter = df_elem_hex.isin(ID_filter)
            element_labels.append(Element_filter[Element_filter.sum(axis=1) == 8].index.values + 1)

    return sec_labels, element_labels

#### Performing a parallel loop to assign the partitions
section_labels = Parallel(n_jobs=-1)(delayed(search_section)(counter) for counter in inputs)

### Distribuing the nodes for each partition
Node_Sections = []
for i in inputs:
    Node_Sections = Node_Sections + section_labels[i][0]

### Distribuing the elements for each partition
Elem_Sections = []
for i in inputs:
    Elem_Sections = Elem_Sections + section_labels[i][1]

####### Storing node-partition and element-partition to Pandas dataframes and saving the dataframes
## node-partition
df_sec_node = pd.DataFrame(Node_Sections)
df_sec_node.to_csv("Node_sections.csv", index=False)
print("Number of sections is:", df_sec_node.shape[0])
## element-partition
df_sec_elem = pd.DataFrame(Elem_Sections)
df_sec_elem.to_csv("Elem_sections.csv", index=False)
print("Number of sections is:", df_sec_elem.shape[0])

######## Detecting the boundary
TOP = 5.0  ### Top boundary (Y = 5)
TOP_ID = df_node[df_node["Y"] == TOP]["ID"].values
BOTTOM = 0.0  ### Bottom boundary (Y = 0)
BOTTOM_ID = df_node[df_node["Y"] == BOTTOM]["ID"].values

#######################################
### Writing the output file for MuPhiSim
outFile = open(Output, "w")

### Writing nodes
outFile.write("*Node\n")
x = df_node.to_string(header=False, index=False).split('\n')
vals = [',          '.join(ele.split()) for ele in x]

for i in range(len(vals)):
    outFile.write("      " + vals[i] + "\n")

### Writing elements
outFile.write("*Element, type=C3D4\n")
x = df_elem.to_string(header=False, index=False).split('\n')
vals = [', '.join(ele.split()) for ele in x]

for i in range(len(vals)):
    outFile.write(vals[i] + "\n")

#### Writing MM nodes and elements
outFile.write("*FEM Nodes\n")
outFile.write("All\n")
outFile.write("*FEM Elements\n")
outFile.write("All\n")

### List of nodes for each CPU
for i in range(Total_sections):
    outFile.write("*NSET=c" + str(i+1) + "\n")
    outFile.write("*CPU=" + str(i+1) + "\n")
    x = df_sec_node.iloc[i].to_string(header=False, index=False)
    outFile.write(x + "\n")

### List of elements for each CPU
for i in range(Total_sections):
    outFile.write("*ELSET=c" + str(i+1) + "\n")
    outFile.write("*CPU=" + str(i+1) + "\n")
    temp = df_sec_elem.iloc[i] * 6
    for j in range(1, 6):
        temp = temp.append(df_sec_elem.iloc[i] * 6 - j)

    x = (temp.sort_values()).to_string(header=False, index=False)
    outFile.write(x + "\n")

#### Writing solver parameters
outFile.write("*SOLVER, IMPLICIT STATIC" +  "\n")
outFile.write("*Scale Factor" +  "\n")
outFile.write("10000" +  "\n")
outFile.write("*Outputs" +  "\n")
outFile.write("100" +  "\n")
outFile.write("All, max" +  "\n")
outFile.write("*Time" +  "\n")
outFile.write("0,1" +  "\n")
outFile.write("*BOUNDARY, TYPE=DISPLACEMENT RAMP" +  "\n")
### TOP boundary conditions
for i in range(len(BOTTOM_ID)):
    outFile.write(str(BOTTOM_ID[i]) + ",0,0" + "\n")  ### X = 0
    outFile.write(str(BOTTOM_ID[i]) + ",1,0" + "\n")  ### Y = 0
    outFile.write(str(BOTTOM_ID[i]) + ",2,0" + "\n")  ### Z = 0
### BOTTOM boundary conditions
for i in range(len(TOP_ID)):
    outFile.write(str(TOP_ID[i]) + ",1,-0.001" + "\n")  ### Y = -0.001

#### Writing the final lines (Constitutive model and material parameters)
outFile.write("*END SOLVER" +  "\n")
outFile.write("*MATERIAL, name=mat1" +  "\n")
outFile.write("*Density" +  "\n")
outFile.write("7000" +  "\n")
outFile.write("*HyperElastic, St-Venant-Kirchhoff" +  "\n")
outFile.write("1e9,0.3" +  "\n")
outFile.write("*List of Elements" +  "\n")
outFile.write("All" +  "\n")
outFile.write("*END" +  "\n")

### Closing the file
outFile.close()
